<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CS180 – Project 2 · Convolution and Filtering · Mario Gonzalez</title>

  <!-- Site styles (already in your repo root) -->
  <link rel="stylesheet" href="../styles.css" />

  <!-- MathJax for LaTeX rendering -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(','\\)'], ['$', '$']],
        displayMath: [['\\[','\\]']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

  <style>
    /* Small, page-local niceties */
    .hero h1 { margin-bottom: .25rem; }
    .hero p.part-note { opacity:.8 }
    figure.media { margin: 1rem auto; }
    figure.media img { width: 100%; height: auto; display:block; }
    figure.media figcaption { text-align:center; font-size:.95rem; opacity:.85; margin-top:.5rem }
    .kpi { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:10px; margin:.5rem 0 1.25rem; }
    .kpi div { background: var(--card); padding:.75rem 1rem; border-radius:10px; }
    .section h3 { margin-top: 1.25rem; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: .92rem; }
    .callout { background: var(--card); border-left: 4px solid var(--accent); padding:.9rem 1rem; border-radius:8px; }
    .refs li { margin-bottom: .4rem; }
  </style>
</head>

<body>
  <!-- Navbar -->
  <header class="nav-band">
    <nav class="nav container" aria-label="Primary">
      <a href="../index.html">Home</a>
      <a href="index.html" class="active" aria-current="page">Project 2</a>
    </nav>
  </header>

  <!-- Hero -->
  <section class="hero">
    <div class="container">
      <h1>Convolution and Filtering</h1>
      <p class="part-note">CS180 · Fall 2025 · Mario Gonzalez</p>
      <a class="btn" href="../index.html">Back to Home <span class="chev" aria-hidden="true">›</span></a>
    </div>
  </section>

  <!-- Abstract -->
  <section class="section" id="abstract">
    <div class="container">
      <h2 class="section-title">Abstract</h2>
      <p>
        This project investigates core linear operators for image processing and their role in multi-scale analysis.
        Beginning with discrete two-dimensional convolution and finite differences, the report transitions to derivatives
        of a Gaussian to control noise amplification. Frequency manipulation is then explored through unsharp masking,
        hybrid images, and Gaussian/Laplacian stacks culminating in multi-resolution blending. Across sections, equations
        are given in LaTeX and experiments are documented with fixed seeds, kernel sizes, and sigmas to ensure
        reproducibility.
      </p>
      <div class="kpi">
        <div><strong>Language & libs</strong><br><span class="small mono">Python · NumPy · SciPy · scikit-image</span></div>
        <div><strong>Convolution</strong><br><span class="small">from-scratch (4-loop / 2-loop) and reference (SciPy)</span></div>
        <div><strong>Stacks</strong><br><span class="small">Gaussian and Laplacian at fixed resolution (no downsample)</span></div>
        <div><strong>Blending</strong><br><span class="small">Burt–Adelson multi-resolution compositing</span></div>
      </div>
    </div>
  </section>

   <!-- ====================== PART 1A ====================== -->
  <section id="part1a" class="section">
    <div class="container">
      <h2 class="section-title">1A · Discrete Convolution</h2>

      <p>
        Let \(I \in \mathbb{R}^{H\times W}\) and a filter \(K \in \mathbb{R}^{(2r+1)\times(2c+1)}\). The discrete
        convolution is
        \[
          (I * K)[x,y] \;=\; \sum_{u=-r}^{r}\sum_{v=-c}^{c} I[x-u,\,y-v]\;K[u,v],
        \]
        implemented with zero padding and kernel flipping. Two custom implementations are provided: a pedagogical
        <span class="mono">conv2d_four_loops</span> (explicit loops over spatial and kernel indices) and an optimized
        <span class="mono">conv2d_two_loops</span> (only loops over spatial indices; inner products vectorized). Results
        are verified against <span class="mono">scipy.signal.convolve2d</span> in “same” mode with fill boundary
        conditions. Box kernels are DC-normalized to preserve average intensity.
      </p>

      <div class="card" style="padding:16px"> <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-bottom:12px"> <label><strong>Dataset:</strong> <select id="a-dataset"></select></label> <strong>k = <span id="a-kval">3</span></strong> <input id="a-kIdx" type="range" min="0" max="0" step="1" value="0" style="width:240px" aria-label="kernel size"> <label><input type="radio" name="a-impl" value="fourloops" checked> From scratch</label> <label><input type="radio" name="a-impl" value="scipy"> SciPy</label> </div>

      <figure class="media media--narrow" style="margin:0 auto"> <img id="a-img" alt="1A result"> <figcaption id="a-cap" style="text-align:center; margin-top:8px"></figcaption> </figure> </div>
  </section>

  <!-- ====================== PART 1B ====================== -->
  <section id="part1b" class="section">
    <div class="container">
      <h2 class="section-title">1B – Finite Difference Operator</h2>

      <p>
        Spatial derivatives are estimated with forward-difference stencils \(D_x = [-1,\,1]\) and \(D_y = D_x^\top\).
        Convolving a grayscale image \(I\) yields
        \[
          I_x = I * D_x,\qquad I_y = I * D_y,
        \]
        and the gradient magnitude
        \[
          \|\nabla I\| = \sqrt{I_x^2 + I_y^2}.
        \]
        Thresholding \(\|\nabla I\|\) produces edge maps. While straightforward, raw differencing is sensitive to noise,
        motivating derivative-of-Gaussian filters in the next section.
      </p>

      <div class="card" style="padding:16px">
        <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-bottom:12px">
          <label><input type="radio" name="b-mode" value="Ix" checked> Ix</label>
          <label><input type="radio" name="b-mode" value="Iy"> Iy</label>
          <label><input type="radio" name="b-mode" value="gradmag"> |∇I|</label>
          <label><input type="radio" name="b-mode" value="edges"> Edges</label>

          <span id="b-thr-wrap" style="display:none; gap:10px; align-items:center;">
            <strong>t = <span id="b-tval">10</span></strong>
            <input id="b-tIdx" type="range" min="0" max="4" step="1" value="0" style="width:220px" aria-label="edge threshold">
          </span>
        </div>

        <figure class="media media--narrow" style="margin:0 auto">
          <img id="b-img" alt="1B result">
          <figcaption id="b-cap" style="text-align:center; margin-top:8px"></figcaption>
        </figure>
      </div>
    </div>
  </section>

  <!-- ====================== PART 1C ====================== -->
  <section id="part1c" class="section">
    <div class="container">
      <h2 class="section-title">1C – Derivative of Gaussian (DoG)</h2>

      <p>
        Noise amplification from plain differences is mitigated by smoothing with a Gaussian \(G_\sigma\).
        Two equivalent pipelines are compared:
      </p>
      <div class="callout small">
        (i) <em>Smooth–then–difference</em>:
        \(\;I_x = (I * G_\sigma) * D_x,\; I_y = (I * G_\sigma) * D_y.\)<br/>
        (ii) <em>Derivative of Gaussian</em>:
        \(\;I_x = I * \tfrac{\partial G_\sigma}{\partial x},\; I_y = I * \tfrac{\partial G_\sigma}{\partial y}.\)
      </div>
      <p>
        With matched \(\sigma\) and support (\(k \approx 6\sigma + 1\)), both pipelines yield nearly identical
        \(\{I_x, I_y, \|\nabla I\|\)\) while the DoG route consolidates operations and is simpler to reason about in
        the Fourier domain.
      </p>

      <div class="card" style="padding:16px">
        <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-bottom:12px">
          <label><input type="radio" name="c-impl" value="smoothdiff" checked> Smooth → Diff</label>
          <label><input type="radio" name="c-impl" value="DoG"> DoG (∂G ⊗ I)</label>

          <span style="margin-left:12px"></span>

          <label><input type="radio" name="c-mode" value="Ix" checked> Ix</label>
          <label><input type="radio" name="c-mode" value="Iy"> Iy</label>
          <label><input type="radio" name="c-mode" value="gradmag"> |∇I|</label>
        </div>

        <figure class="media media--narrow" style="margin:0 auto">
          <img id="c-img" alt="1C result">
          <figcaption id="c-cap" style="text-align:center; margin-top:8px"></figcaption>
        </figure>
      </div>

      <p>
        I ended up replacing the raw differences with derivatives of a Gaussian. A normalized Gaussian kernel
        <code>G<sub>σ</sub></code> is constructed using
        <code>ksize ≈ 6σ + 1</code> to capture sufficient support. Two pipelines are compared: (i) smoothing the image
        with <code>G<sub>σ</sub></code> and then applying <code>Dx</code>/<code>Dy</code>; and (ii) forming the DoG
        filters <code>∂G/∂x</code>, <code>∂G/∂y</code> (by convolving <code>G</code> with the difference stencils) and
        applying a single convolution per axis. Both methods yield near-identical <code>Ix</code>, <code>Iy</code>, and
        <code>|∇I|</code> when σ and support are matched, but the DoG route is computationally attractive and conceptually
        cleaner.
      </p>
    </div>
  </section>

  <!-- ====================== PART 2A ====================== -->
  <section id="part2a" class="section">
    <div class="container">
      <h2 class="section-title">2A – Unsharp Masking / Sharpening</h2>

      <p>
        Unsharp masking enhances high spatial frequencies by subtracting a Gaussian-blurred version from the original:
        \[
          \text{blur} = I * G_\sigma,\qquad
          \text{high} = I - \text{blur},\qquad
          I'=\operatorname{clip}\!\big(I + \alpha\cdot \text{high}\big).
        \]
        The parameter \(\sigma\) controls the <em>radius</em> of detail considered “high”; \(\alpha\) scales contrast of
        those details. A small \(\sigma\) with larger \(\alpha\) sharpens fine texture; a larger \(\sigma\) with modest
        \(\alpha\) improves mid-scale edge crispness. To prevent boosting sensor noise and scratches in archival
        photographs, an optional soft threshold \(\tau\) suppresses \(|\text{high}| \le \tau\).
      </p>

      <div class="card" style="padding:16px">
        <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-bottom:12px">
          <label><strong>Dataset:</strong>
            <select id="ua-dataset">
              <option value="taj" selected>Taj</option>
              <option value="Grandpa">Grandpa</option>
            </select>
          </label>

          <label><input type="radio" name="ua-view" value="src" checked> Source</label>
          <label><input type="radio" name="ua-view" value="blur"> Blurred (low-pass)</label>
          <label><input type="radio" name="ua-view" value="high"> High-pass</label>
          <label><input type="radio" name="ua-view" value="sharp"> Sharpened</label>
        </div>

        <figure class="media media--narrow" style="margin:0 auto">
          <img id="ua-img" alt="2A result">
          <figcaption id="ua-cap" style="text-align:center; margin-top:8px"></figcaption>
        </figure>
      </div>

      <p>
        Unsharp masking: <code>blur = G<sub>σ</sub> ⊗ I</code>, <code>high = I − blur</code>, <code>I′ = clip(I + α·high)</code>.
      </p>
    </div>
  </section>

  <!-- ====================== PART 2B ====================== -->
  <section id="part2b" class="section">
    <div class="container">
      <h2 class="section-title">2B – Hybrid Images</h2>

      <p>
        Hybrid images juxtapose low-frequency structure from one source with high-frequency detail from another so that
        perception depends on viewing distance. Given images \(A\) and \(B\),
        \[
          A_{\text{low}} = A * G_{\sigma_\ell}, \qquad
          B_{\text{high}} = B - (B * G_{\sigma_h}), \qquad
          H = A_{\text{low}} + \beta\cdot B_{\text{high}}.
        \]
        Following Oliva–Torralba, color generally derives from the low-pass term while the high-pass is injected in
        luminance to avoid chroma halos. Energy balancing (\(\beta\)) is chosen so that
        \(\operatorname{std}(A_{\text{low}}) \approx \operatorname{std}(\beta\cdot B_{\text{high}})\) in a central window.
      </p>

      <div class="card" style="padding:16px">
        <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-bottom:12px">
          <label><strong>Set:</strong>
            <select id="hy-set">
              <option value="example" selected>Derek and Nutmeg</option>
              <option value="maga" selected>Jump Scare (Current Administration)</option>
            </select>
          </label>

          <label><input type="radio" name="hy-view" value="A" checked> Image A</label>
          <label><input type="radio" name="hy-view" value="low"> A: Low-Pass</label>
          <label><input type="radio" name="hy-view" value="B"> Image B</label>
          <label><input type="radio" name="hy-view" value="high"> High-pass(B)</label>
          <label><input type="radio" name="hy-view" value="hybrid"> Hybrid</label>
        </div>

        <figure class="media media--narrow" style="margin:0 auto">
          <img id="hy-img" alt="2B result">
          <figcaption id="hy-cap" style="text-align:center; margin-top:8px"></figcaption>
        </figure>
      </div>
    </div>
  </section>

  <!-- ====================== PART 2C ====================== -->
  <section id="part2c" class="section">
    <div class="container">
      <h2 class="section-title">2C – Gaussian & Laplacian Stacks</h2>
      <p>
        A Gaussian stack \(\{G^0, \dots, G^{L-1}\}\) is formed by repeated convolution of the image with \(G_\sigma\)
        at a fixed resolution. The corresponding Laplacian stack isolates band-pass information:
        \[
          L^i \;=\; G^i - (G^i * G_\sigma), \quad i=0,\dots,L-2, \qquad
          L^{L-1} \;=\; G^{L-1}.
        \]
        Visualizing \(\{L^i\}\) with symmetric normalization makes positive/negative lobes visible while preserving
        relative band energy.
      </p>

      <div class="card" style="padding:16px">
        <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-bottom:12px">
          <label><strong>Image:</strong>
            <select id="st-img">
              <option value="apple" selected>Apple</option>
              <option value="orange">Orange</option>
            </select>
          </label>

          <label><input type="radio" name="st-type" value="gauss" checked> Gaussian Stack</label>
          <label><input type="radio" name="st-type" value="lap"> Laplacian Stack</label>
        </div>

        <figure class="media media--narrow" style="margin:0 auto">
          <img id="st-view" alt="2C result">
          <figcaption id="st-cap" style="text-align:center; margin-top:8px"></figcaption>
        </figure>
      </div>
    </div>
  </section>

  <!-- ====================== PART 2D ====================== -->
  <section id="part2d" class="section">
    <div class="container">
      <h2 class="section-title">2D – Multiresolution Blending</h2>


      <p>
        Multi-resolution blending follows Burt–Adelson. Given images \(A,B\) and a soft mask \(M\in[0,1]\), construct
        Gaussian stacks of the mask \(\{M^i\}\) and Laplacian stacks \(\{L_A^i\},\{L_B^i\}\). Blend per level,
        \[
          \tilde{L}^i \;=\; M^i \odot L_A^i \;+\; (1-M^i)\odot L_B^i,
        \]
        then reconstruct by summation,
        \[
          R \;=\; \sum_{i=0}^{L-1} \tilde{L}^i.
        \]
        A sufficiently wide feather on \(M\) removes seams at fine scales while Gaussianized \(M^i\) ensures the blend
        respects both broad illumination and local texture. All blending is performed in linear-RGB; results are finally
        mapped back to sRGB for display.
      </p>

      <div class="card" style="padding:16px">
        <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin-bottom:12px">
          <label><strong>Mask:</strong>
            <select id="blend-mask">
              <option value="vertical" selected>Vertical</option>
              <option value="irregular">Irregular</option>
            </select>
          </label>

          <label><input type="radio" name="blend-view" value="result" checked> Result</label>
          <label><input type="radio" name="blend-view" value="mask_stack"> Mask Stack</label>
          <label><input type="radio" name="blend-view" value="lap_blended"> Laplacian Blended Stack</label>
        </div>

        <figure class="media media--narrow" style="margin:0 auto">
          <img id="blend-img" alt="2D result">
          <figcaption id="blend-cap" style="text-align:center; margin-top:8px"></figcaption>
        </figure>
        <div class="callout small">
        <strong>Implementation notes.</strong> Gaussian stack kernel sizes follow \(k=2\lfloor 3\sigma\rfloor+1\).
        Stack depth \(L\in[6,10]\) balances runtime and low-frequency coverage. The mask is pre-feathered by
        \(\sigma_M \approx \tfrac{\text{feather px}}{6}\) to suppress ringing in \(\tilde{L}^0\).
      </div>
      </div>

  

  <!-- ====================== Shared JS helpers ====================== -->
  <script>
  (function(){
    const EXTS = ['png','jpg','jpeg'];
    const $ = s => document.querySelector(s);

    function tryLoad(imgEl, paths, i=0){
      if(i >= paths.length){ imgEl.removeAttribute('src'); return; }
      imgEl.onerror = () => tryLoad(imgEl, paths, i+1);
      imgEl.src = paths[i];
    }
    function onRadios(name, cb){
      document.querySelectorAll(`input[name="${name}"]`).forEach(r => r.addEventListener('change', cb));
    }
    window.UI = {EXTS, $, tryLoad, onRadios};
  })();
  </script>

  <!-- ====================== 1A viewer ====================== -->
  <script>
  (function () {
    const {EXTS, $, tryLoad, onRadios} = UI;
    const CONFIG = {
      base: 'media/part1',
      datasets: [{ id: 'box', label: 'Box Filter', ks: [3,5,9,15] }]
    };

    const dsSel = $('#a-dataset'), kIdx = $('#a-kIdx'), kval = $('#a-kval'),
          img = $('#a-img'), cap = $('#a-cap');

    CONFIG.datasets.forEach(d => {
      const o = document.createElement('option'); o.value = d.id; o.textContent = d.label;
      dsSel.appendChild(o);
    });

    const curDS = () => CONFIG.datasets.find(d => d.id === dsSel.value);
    const curImpl = () => document.querySelector('input[name="a-impl"]:checked').value;

    function setSlider(ds){
      kIdx.min = 0; kIdx.max = ds.ks.length - 1;
      if(+kIdx.value > +kIdx.max) kIdx.value = 0;
    }

    function update(){
      const ds = curDS(), k = ds.ks[+kIdx.value], impl = curImpl();
      kval.textContent = k;
      cap.textContent = `${ds.label} — ${impl==='fourloops'?'From scratch':'SciPy'} (k=${k})`;
      const paths = EXTS.map(ext => `${CONFIG.base}/${ds.id}/${ds.id}_${impl}_k${k}.${ext}`);
      tryLoad(img, paths);
    }

    dsSel.addEventListener('change', () => { setSlider(curDS()); update(); });
    kIdx.addEventListener('input', update);
    onRadios('a-impl', update);

    setSlider(curDS()); update();
  })();
  </script>

  <!-- ====================== 1B viewer ====================== -->
  <script>
  (function () {
    const {EXTS, $, tryLoad, onRadios} = UI;
    const BASE = 'media/part1_2';
    const THRESH = [10,15,20,25,30];

    const mode = () => document.querySelector('input[name="b-mode"]:checked').value;
    const tIdx = $('#b-tIdx'), tVal = $('#b-tval'), thrWrap = $('#b-thr-wrap'),
          img = $('#b-img'), cap = $('#b-cap');

    function candidates(){
      const m = mode();
      if(m==='edges'){
        const t = THRESH[+tIdx.value];
        tVal.textContent = t;
        return EXTS.map(ext => `${BASE}/p1_2_edges_t${t}.${ext}`);
      }
      const file = m==='Ix' ? 'p1_2_Ix' : m==='Iy' ? 'p1_2_Iy' : 'p1_2_gradmag';
      return EXTS.map(ext => `${BASE}/${file}.${ext}`);
    }

    function update(){
      thrWrap.style.display = (mode()==='edges') ? 'inline-flex' : 'none';
      const label = (mode()==='gradmag') ? '|∇I|' : mode();
      cap.textContent = `Finite difference — ${label}` + (mode()==='edges' ? ` (t=${THRESH[+tIdx.value]})` : '');
      tryLoad(img, candidates());
    }

    onRadios('b-mode', update);
    tIdx.addEventListener('input', update);
    update();
  })();
  </script>

  <!-- ====================== 1C viewer ====================== -->
  <script>
  (function () {
    const {EXTS, $, tryLoad, onRadios} = UI;
    const BASE = 'media/part1_3';

    const impl = () => document.querySelector('input[name="c-impl"]:checked').value;
    const mode = () => document.querySelector('input[name="c-mode"]:checked').value;
    const img  = $('#c-img'), cap = $('#c-cap');

    function update() {
      const m = mode();
      const i = impl() === 'smoothdiff' ? 'Smooth → Diff' : 'DoG';
      cap.textContent = `1C — ${i}, ${m === 'gradmag' ? '|∇I|' : m}`;
      const file = `p1_3_${m}_${impl()}`;
      tryLoad(img, EXTS.map(ext => `${BASE}/${file}.${ext}`));
    }

    onRadios('c-impl', update);
    onRadios('c-mode', update);
    update();
  })();
  </script>

  <!-- ====================== Config for Part 2D datasets ====================== -->
  <script id="blend-config" type="application/json">
  {
    "base": "media/part2_4",
    "exts": ["png","jpg","jpeg"],
    "datasets": [
      {
        "id": "oraple",
        "label": "Oraple ",
        "stems": {
          "result": "{id}_{mask}",
          "mask_stack": "mask_stack_{mask}",
          "lap_blended": "lap_blended_{mask}"
        }
      },
      {
        "id": "sbrainer",
        "label": "Santa Barbara ⊕ Rainer (irregular mask)",
        "stems": {
          "result": "sbrainer",
          "mask_stack": "stacks_rainer_sb_rainer_mask_L10_k17_s8.0_f65_lin_Gmask_grid",
          "lap_blended": "stacks_rainer_sb_rainer_mask_L10_k17_s8.0_f65_lin_Ls_grid"
        }
      },
      {

      "id": "bell_clouds",
      "label": "Campanile ⊕ Nighttime Clouds",
      "stems": {
        "result": "bell_clouds",
        "mask_stack": "stacks_clouds_bell_night_cloud_mask_L6_k17_s16.0_f65_lin_Gmask_grid",
        "lap_blended": "stacks_clouds_bell_night_cloud_mask_L6_k17_s16.0_f65_lin_Ls_grid"
      }
    }
    ]
  }
  </script>

  <!-- === Single driver for ALL Part 2 viewers (2A/2B/2C/2D) === -->
  <script>
  (function(){
    const EXTS = (window.UI && UI.EXTS) || ['png','jpg','jpeg'];
    const $    = (window.UI && UI.$)    || (s => document.querySelector(s));
    const tryLoad = (window.UI && UI.tryLoad) || function(imgEl, paths, i=0){
      if(i>=paths.length){ imgEl.removeAttribute('src'); return; }
      imgEl.onerror = () => tryLoad(imgEl, paths, i+1);
      imgEl.src = paths[i];
    };

    function makePart2Viewer({base, imgSel, capSel, watch, resolve, exts=EXTS}) {
      const img = $(imgSel), cap = $(capSel);

      function readState() {
        const s = {};
        for (const w of watch) {
          if (w.kind === 'radio') {
            const el = document.querySelector(`input[name="${w.name}"]:checked`);
            s[w.as] = el ? el.value : undefined;
          } else if (w.kind === 'select') {
            const el = document.getElementById(w.id);
            s[w.as] = el ? el.value : undefined;
          }
        }
        return s;
      }

      function update() {
        const state = readState();
        const { stem, stems, label } = resolve(state) || {};
        const list = stems || (stem ? [stem] : []);
        if (label) cap.textContent = label;
        if (!list.length) { img.removeAttribute('src'); return; }
        const paths = [];
        for (const s of list) for (const ext of exts) paths.push(`${base}/${s}.${ext}`);
        tryLoad(img, paths);
      }

      for (const w of watch) {
        if (w.kind === 'radio') {
          document.querySelectorAll(`input[name="${w.name}"]`).forEach(r => r.addEventListener('change', update));
        } else if (w.kind === 'select') {
          const el = document.getElementById(w.id);
          if (el) el.addEventListener('change', update);
        }
      }
      update();
      return update;
    }

    // ---------- 2A ----------
    makePart2Viewer({
      base: 'media/part2_1',
      imgSel: '#ua-img',
      capSel: '#ua-cap',
      watch: [
        {kind:'select', id:'ua-dataset', as:'ds'},
        {kind:'radio',  name:'ua-view',  as:'view'}
      ],
      resolve: ({ds, view}) => {
        const nice = {src:'Source', blur:'Blurred (LPF)', high:'High-pass', sharp:'Sharpened'}[view] || view;
        const stemBy = {
          taj:  {src:'taj', blur:'taj_blur', high:'taj_high', sharp:'taj_sharp'},
          Grandpa: {src:'gp', blur:'gp_blurred', high:'gp_high', sharp:'gp_4_final'}
        };
        const stem = stemBy[ds]?.[view] || null;
        return { stem, label: `${ds==='taj'?'Taj':'Grandpa'} • ${nice}` };
      }
    });

    // ---------- 2B ----------
    makePart2Viewer({
      base: 'media/part2_2',
      imgSel: '#hy-img',
      capSel: '#hy-cap',
      watch: [
        {kind:'select', id:'hy-set',   as:'set'},
        {kind:'radio',  name:'hy-view',as:'view'}
      ],
      resolve: ({set, view}) => {
        // Map stems per dataset
        const stemsBySet = {
          example: { A:'A', low:'low', B:'B', high:'high', hybrid:'hybrid' },
          maga:    { A:'vance', low:'low_vance', B:'trump', high:'high_trump', hybrid:'tj_hybrid' }
        };
        const names = {
          A:'(low-freq detial)', low:'Low-pass',
          B:'(high-freq detail)', high:'High-pass(B)', hybrid:'Hybrid'
        };
        const stem = (stemsBySet[set] || stemsBySet.example)[view] || null;
        return { stem, label: `${set==='example'?'Example':'Jump Scare'} • ${names[view]||view}` };
      }
    });

    // ---------- 2C ----------
    makePart2Viewer({
      base: 'media/part2_3',
      imgSel: '#st-view',
      capSel: '#st-cap',
      watch: [
        {kind:'select', id:'st-img',    as:'img'},
        {kind:'radio',  name:'st-type', as:'type'}
      ],
      resolve: ({img, type}) => {
        const name = img==='apple' ? 'Apple' : 'Orange';
        return { stem: `${type}_${img}`, label: `2C — ${type==='gauss'?'Gaussian':'Laplacian'} stack • ${name}` };
      }
    });

    // ---------- 2D ----------
    makePart2Viewer({
      base: (function(){
        const el = document.querySelector('#blend-config');
        if (!el) return 'media/part2_4';
        try { return JSON.parse(el.textContent).base || 'media/part2_4'; }
        catch (_) { return 'media/part2_4'; }
      })(),
      imgSel: '#blend-img',
      capSel: '#blend-cap',
      watch: [
        {kind:'select', id:'blend-ds',  as:'ds'},
        {kind:'select', id:'blend-mask',as:'mask'},
        {kind:'radio',  name:'blend-view', as:'view'}
      ],
      resolve: ({ds, mask, view}) => {
        const el = document.querySelector('#blend-config');
        let CFG = null;
        if (el) { try { CFG = JSON.parse(el.textContent); } catch(_){} }
        const datasets = CFG?.datasets || [{id:'oraple', label:'Oraple', stems:{
          result:'{id}_{mask}', mask_stack:'mask_stack_{mask}', lap_blended:'lap_blended_{mask}'
        }}];

        // Ensure a dataset selector exists; create if missing
        let dsSel = document.querySelector('#blend-ds');
        if (!dsSel) {
          const controls = document.querySelector('#blend-mask').closest('div');
          const lab = document.createElement('label');
          lab.innerHTML = '<strong>Pair:</strong> <select id="blend-ds"></select>';
          controls.insertBefore(lab, controls.firstChild);
          dsSel = lab.querySelector('select');
          dsSel.innerHTML = datasets.map(d=>`<option value="${d.id}">${d.label||d.id}</option>`).join('');
          dsSel.addEventListener('change', () => document.querySelector('input[name="blend-view"]:checked').dispatchEvent(new Event('change')));
        }

        const active = datasets.find(d => d.id === (ds || dsSel.value)) || datasets[0];
        if (dsSel && dsSel.value !== active.id) dsSel.value = active.id;

        const tpl = active.stems?.[view];
        const rel = tpl ? tpl.replace(/\{(\w+)\}/g, (_,k)=>({id:active.id,mask}[k]??'')) : `${active.id}_${mask}`;
        const vname = view==='result' ? 'Result' : (view==='mask_stack' ? 'Mask stack' : 'Laplacian blended stack');
        const mname = mask==='vertical' ? 'vertical' : 'Irregular';
        return { stem: rel, label: `${active.label||active.id}` };
      }
    });

  })();
  </script>
</body>
</html>
