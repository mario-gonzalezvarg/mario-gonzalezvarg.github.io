<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Project 3A – Stitching Photo Mosaics</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="../../styles.css" />
  <script>
    window.MathJax = {
      tex: { inlineMath: [['\\(', '\\)']], displayMath: [['\\[', '\\]']] },
      options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
    };
  </script>
  <script async id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

</head>

<body class="top-title">

  <canvas id="sky" aria-hidden="true"></canvas>

  <header class="site-header">
    <div class="content">
      <nav class="top-nav" aria-label="Project navigation">
        <a href="../../index.html" class="nav-logo">Home</a>
      </nav>
    </div>

  </header>

  <div class="content big-title">
    <h1 class="title">Image Warping and Mosaicing</h1>
    <div class="project-switcher" aria-label="Jump to project parts">
      <a href="./part3a.html" class="project-switcher__button project-switcher__button--primary">
        Part A
      </a>
      <a href="../partb/part3b.html" class="project-switcher__button">
        Part B
      </a>
    </div>
  </div>

  <!-- =============================== Overview =============================== -->
  <section class="content gold-glass writing-section" id="overview">
    <h2 class="section-heading">Overview</h2>
    <p>
      Panoramic mosaicing can be generalized as a sequence of constrained transformations that converts multiple partial
      views into a single consistent image. The pipeline separates into correspondence selection, homography estimation,
      geometric warping into a common coordinate system, and photometric blending to suppress visible seams.
    </p>
    <p>
      The evidence for each transformation is confined to repeated conjunctions of local appearances across overlapping
      images. A correspondence asserts that two pixel neighborhoods are distinct appearances of one scene point; a
      homography is accepted when it explains many such assertions while rejecting accidental alignments. The resulting
      mosaic is therefore a stabilized representation: relations that persist across viewpoints are preserved, and
      relations that fail under re-projection are treated as noise.
    </p>
  </section>

  <!-- ================================================================== A.1: Photoshot ============================================================= -->
  <section class="content gold-glass iteration-belt iteration-belt--two-rows" id="a1">
    <h2 class="section-heading">A.1 Shoot Photos</h2>

    <div class="iteration-belt__intro">
      <p>
        Two overlapping sequences are captured under camera rotation about a fixed center of projection. This capture
        condition makes the inter-image motion well-approximated by a single projective transform, providing the raw
        constraints used later to recover a homography.
      </p>
    </div>

    <div class="iteration-belt__header">
      <h3 class="iteration-belt__title">Captured image sequences</h3>
      <button type="button" class="iteration-belt__toggle" aria-pressed="false">Pause</button>
    </div>

    <!-- Row 1: Catalina -->
    <div class="iteration-belt__row">
      <h3 class="iteration-belt__row-title">Catalina Island, California</h3>
      <div class="iteration-belt__viewport">
        <div class="iteration-belt__track">

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/catalina/IMG_1693.JPG"
              alt="Catalina Island photo, view 1" loading="lazy">
            <figcaption class="iteration-belt__caption">View 1</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/catalina/IMG_1694.JPG"
              alt="Catalina Island photo, view 2" loading="lazy">
            <figcaption class="iteration-belt__caption">View 2</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/catalina/IMG_1695.JPG"
              alt="Catalina Island photo, view 3" loading="lazy">
            <figcaption class="iteration-belt__caption">View 3</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/catalina/IMG_1696.JPG"
              alt="Catalina Island photo, view 4" loading="lazy">
            <figcaption class="iteration-belt__caption">View 4</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/catalina/IMG_1697.JPG"
              alt="Catalina Island photo, view 5" loading="lazy">
            <figcaption class="iteration-belt__caption">View 5</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/catalina/IMG_1698.JPG"
              alt="Catalina Island photo, view 6" loading="lazy">
            <figcaption class="iteration-belt__caption">View 6</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/catalina/IMG_1699.JPG"
              alt="Catalina Island photo, view 7" loading="lazy">
            <figcaption class="iteration-belt__caption">View 7</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/catalina/IMG_1700.JPG"
              alt="Catalina Island photo, view 8" loading="lazy">
            <figcaption class="iteration-belt__caption">View 8</figcaption>
          </figure>

        </div>
      </div>
    </div>

    <!-- Row 2: Grand Canyon -->
    <div class="iteration-belt__row">
      <h3 class="iteration-belt__row-title">Grand Canyon, Arizona</h3>
      <div class="iteration-belt__viewport">
        <div class="iteration-belt__track">

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/canyon/IMG_7135.JPG"
              alt="Grand Canyon photo, view 1" loading="lazy">
            <figcaption class="iteration-belt__caption">View 1</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/canyon/IMG_7136.JPG"
              alt="Grand Canyon photo, view 2" loading="lazy">
            <figcaption class="iteration-belt__caption">View 2</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/canyon/IMG_7137.JPG"
              alt="Grand Canyon photo, view 3" loading="lazy">
            <figcaption class="iteration-belt__caption">View 3</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/canyon/IMG_7138.JPG"
              alt="Grand Canyon photo, view 4" loading="lazy">
            <figcaption class="iteration-belt__caption">View 4</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/canyon/IMG_7140.JPG"
              alt="Grand Canyon photo, view 5" loading="lazy">
            <figcaption class="iteration-belt__caption">View 5</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/canyon/IMG_7141.JPG"
              alt="Grand Canyon photo, view 6" loading="lazy">
            <figcaption class="iteration-belt__caption">View 6</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/canyon/IMG_7142.JPG"
              alt="Grand Canyon photo, view 7" loading="lazy">
            <figcaption class="iteration-belt__caption">View 7</figcaption>
          </figure>

          <figure class="iteration-belt__item">
            <img class="iteration-belt__image" src="media/1_shootPhotos/canyon/IMG_7143.JPG"
              alt="Grand Canyon photo, view 8" loading="lazy">
            <figcaption class="iteration-belt__caption">View 8</figcaption>
          </figure>

        </div>
      </div>
    </div>

  </section>

  <!-- ================================================================== A.2: Homographies =============================================================== -->
  <section class="content gold-glass iteration-belt" id="a2">
    <h2 class="section-heading">A.2 Recover Homographies</h2>

    <div class="iteration-belt__intro">
      <p>
        Homography estimation can be decomposed into constraint selection and parameter recovery. Each correspondence
        asserts that a point in Image A and a point in Image B are two appearances of the same scene point under a
        change
        in viewpoint. Under the projective camera model, these assertions imply a 3×3 mapping <em>H</em> such that
        <em>p′</em> is proportional to <em>H p</em>.
      </p>

      <p>
        The mapping is recovered by stacking the linear constraints induced by all correspondences into a single system
        and
        solving for <em>H</em> up to scale. The correspondence set is distributed across the overlap so the solution is
        informed by global structure rather than a single local patch.
      </p>
    </div>

    <div class="math-derivation" style="--math-max: 70rem;">
      <div class="math-derivation__title">Constraint stacking as a linear system</div>

      <div class="math-derivation__body">
        <p>Take the homography as</p>
        <div class="math-derivation__eq">
          \[
          H =
          \begin{bmatrix}
          h_1 & h_2 & h_3 \\
          h_4 & h_5 & h_6 \\
          h_7 & h_8 & 1
          \end{bmatrix},
          \quad
          \mathbf{h} =
          \begin{bmatrix}
          h_1 & h_2 & h_3 & h_4 & h_5 & h_6 & h_7 & h_8
          \end{bmatrix}^{\top}.
          \]
        </div>

        <p>
          For each correspondence \((x_i, y_i)\) in <code>view 1</code> and \((x'_i, y'_i)\) in <code>view 5</code>,
          in homogeneous coordinates,
        </p>
        <div class="math-derivation__eq">
          \[
          \begin{bmatrix}
          x'_i \\[2pt] y'_i \\[2pt] 1
          \end{bmatrix}
          \sim
          H
          \begin{bmatrix}
          x_i \\[2pt] y_i \\[2pt] 1
          \end{bmatrix}.
          \]
        </div>

        <p>This gives</p>
        <div class="math-derivation__eq">
          \[
          x'_i = \frac{h_1 x_i + h_2 y_i + h_3}{h_7 x_i + h_8 y_i + 1},
          \quad
          y'_i = \frac{h_4 x_i + h_5 y_i + h_6}{h_7 x_i + h_8 y_i + 1}.
          \]
        </div>

        <p>
          Rearranging to be linear in \(\mathbf{h}\), each point pair contributes two rows to a system
          \(A\mathbf{h}=\mathbf{b}\):
        </p>
        <div class="math-derivation__eq">
          \[
          \begin{bmatrix}
          x_i & y_i & 1 & 0 & 0 & 0 & -x_i x'_i & -y_i x'_i \\
          0 & 0 & 0 & x_i & y_i & 1 & -x_i y'_i & -y_i y'_i
          \end{bmatrix}
          \mathbf{h}
          =
          \begin{bmatrix}
          x'_i \\[2pt] y'_i
          \end{bmatrix}.
          \]
        </div>

        <p>
          Stack these \(2N\) rows from all \(N\) correspondences into a big matrix \(A\) and vector \(\mathbf{b}\), then
          solve
          \(A\mathbf{h}\approx \mathbf{b}\) in least squares to recover \(H\).
        </p>
      </div>
    </div>

    <div class="code-snippets" aria-label="Recovered homography matrix">
      <div class="code-snippets__title">Recovered homography</div>

      <details class="code-snippet" open>
        <summary>H (Catalina View 1 → Catalina View 5)</summary>
        <div class="code-snippet__body">
          <pre class="code-block"><code>[[ 1.77486435e+00  4.04361609e-02 -2.77535848e+03]
              [ 4.42547768e-01  1.61873526e+00 -1.14219166e+03]
              [ 2.37956041e-04  1.77379109e-05  1.00000000e+00]]</code></pre>
        </div>
      </details>
    </div>


    <div class="iteration-belt__outro">
      <p>
        It's crucial to understand that homographies are exact only under restricted imaging conditions. The model
        assumes that the observed
        correspondences
        arise from either a single planar surface or a pure camera rotation about a fixed center; when the scene
        contains
        strong depth variation, parallax causes one global <em>H</em> to align some regions while misaligning others,
        often
        producing double edges and “ghosted” structures near depth discontinuities.
      </p>
    </div>



    <div class="viz-pair" style="--viz-pair-max: 36rem;" role="group"
      aria-label="Selected correspondences for homography estimation">
      <figure class="viz-pair__panel">
        <div class="viz-pair__title">Image A</div>
        <img class="viz-pair__image" src="media/2_homography/imgA.png"
          alt="Image A with selected correspondence points marked" loading="lazy">
      </figure>

      <figure class="viz-pair__panel">
        <div class="viz-pair__title">Image B</div>
        <img class="viz-pair__image" src="media/2_homography/imgB.png"
          alt="Image B with selected correspondence points marked" loading="lazy">
      </figure>
    </div>

    <div class="iteration-belt__outro">
      <p>
        Nnumerical stability also depends on the geometry of the selected points. If correspondences cluster in a small
        area
        or
        lie close to a line, the linear system becomes ill-conditioned and small clicking errors amplify into large
        projective
        distortions, especially in the corners. Better behavior follows from distributing points broadly across the
        overlap
        and including strong 2D structure (corners and junctions) rather than ambiguous texture.
      </p>
    </div>




  </section>

  <!-- ================================================================== A.3 Image Warping ================================================================== -->
  <section class="content gold-glass iteration-belt" id="a3">
    <h2 class="section-heading">A.3 Warp the Images</h2>

    <div class="iteration-belt__intro">
      <p>
        Image warping can be reduced to an inverse mapping from the output canvas back into the source image. Each
        output
        pixel is mapped through <em>H</em><sup>−1</sup> to a continuous source coordinate, and an interpolation rule
        produces a color estimate without leaving holes in the output.
      </p>
      <p>
        Nearest-neighbor interpolation rounds to the closest sampled pixel and therefore preserves speed at the cost of
        jagged edges and staircase artifacts. Bilinear interpolation blends the four neighboring samples, which improves
        edge continuity but increases computation per output pixel. An alpha mask is carried alongside the warp to mark
        pixels that received valid samples within the source bounds.
      </p>
    </div>

    <!-- ============================ Rectification example 1: Frame ============================ -->
    <h3 class="iteration-belt__row-title" style="margin-top: 0.25rem;">Rectification example: Red frame</h3>

    <div class="viz-pair" style="--viz-pair-max: 36rem;" role="group"
      aria-label="Rectification correspondences for the frame example">
      <figure class="viz-pair__panel">
        <div class="viz-pair__title">Source (selected corners)</div>
        <img class="viz-pair__image" src="media/3_warp/frame/frame_points_imgA.png"
          alt="Source photo with four selected corner points on the frame" loading="lazy">
      </figure>

      <figure class="viz-pair__panel">
        <div class="viz-pair__title">Target (ideal rectangle)</div>
        <img class="viz-pair__image" src="media/3_warp/frame/frame_points_imgB.png"
          alt="Target rectangle with four corresponding corner points" loading="lazy">
      </figure>
    </div>

    <div class="viz-pair" style="--viz-pair-max: 36rem;" role="group"
      aria-label="Rectified output comparison by interpolation method (frame)">
      <figure class="viz-pair__panel">
        <div class="viz-pair__title">Nearest neighbor</div>
        <img class="viz-pair__image" src="media/3_warp/frame/warp_nn/redFrame_warped.png"
          alt="Rectified frame using nearest-neighbor interpolation" loading="lazy">
      </figure>

      <figure class="viz-pair__panel">
        <div class="viz-pair__title">Bilinear</div>
        <img class="viz-pair__image" src="media/3_warp/frame/warp_bilinear/redFrame_warped.png"
          alt="Rectified frame using bilinear interpolation" loading="lazy">
      </figure>
    </div>
    <!-- 
  <div class="viz-pair" style="--viz-pair-max: 36rem;" role="group"
       aria-label="Alpha mask comparison by interpolation method (frame)">
    <figure class="viz-pair__panel">
      <div class="viz-pair__title">NN mask</div>
      <img class="viz-pair__image" src="media/3_warp/frame/warp_nn/redFrame_warped_mask.png"
           alt="Alpha mask for the nearest-neighbor frame rectification" loading="lazy">
    </figure>

    <figure class="viz-pair__panel">
      <div class="viz-pair__title">Bilinear mask</div>
      <img class="viz-pair__image" src="media/3_warp/frame/warp_bilinear/redFrame_warped_mask.png"
           alt="Alpha mask for the bilinear frame rectification" loading="lazy">
    </figure>
  </div> -->

    <figure class="viz-pair__panel" style="max-width: 60rem; margin: 1.25rem auto 0;">
      <div class="viz-pair__title">Difference map (|bilinear − NN| × 10)</div>
      <img class="viz-pair__image" src="media/3_warp/frame/diff_x10.png"
        alt="Amplified absolute difference between bilinear and nearest-neighbor warped outputs (scaled by 10)"
        loading="lazy">
    </figure>

    <div class="code-snippets" aria-label="Numeric difference between bilinear and nearest neighbor outputs (frame)">
      <div class="code-snippets__title">Numeric difference (frame)</div>
      <details class="code-snippet" open>
        <summary>diff statistics</summary>
        <div class="code-snippet__body">
          <pre class="code-block"><code>max abs diff: 73
mean abs diff: 2.67347125
pct nonzero:   0.8768875</code></pre>
        </div>
      </details>
    </div>

    <div class="iteration-belt__outro">
      <p>
        The amplified difference map visualizes where interpolation changes pixel values under the same inverse warp.
        The
        mean absolute difference remains small on an 8-bit scale, yet the nonzero rate is high because bilinear perturbs
        a
        large fraction of pixels by 1–3 intensity levels through weighted mixing. The maximum deviation concentrates
        along
        sharp boundaries and fine line structure where nearest neighbor can “jump” across an edge by one pixel while
        bilinear blends across it.
      </p>
    </div>


    <div class="code-snippets" aria-label="Runtime comparison for warping (frame)">
      <div class="code-snippets__title">Runtime comparison (frame)</div>

      <details class="code-snippet" open>
        <summary>redFrame → form (inverse warping)</summary>
        <div class="code-snippet__body">
          <pre class="code-block"><code>Nearest neighbor:
  time_warp_s  = 0.058011
  time_total_s = 5.208443

Bilinear:
  time_warp_s  = 0.192293
  time_total_s = 5.058346

Δ warp  = +0.134282 s  (+231.48%)
Δ total = −0.150097 s  (−2.88%)
</code></pre>
        </div>
      </details>
    </div>

    <div class="iteration-belt__outro">
      <p>
        The runtime gap follows arithmetic density: nearest neighbor performs one fetch per output pixel, while bilinear
        performs four fetches and a weighted blend. Remaining artifacts are typically geometric rather than
        interpolative:
        insufficient output bounds clip content, overly generous bounds increase empty regions, and corner clicking
        error
        propagates as residual shear across the entire planar surface.
      </p>
    </div>

    <!-- ============================ Rectification example 2: Sticker (pink) ============================ -->
    <h2 class="iteration-belt__row-title" style="margin-top: 2.0rem;">Rectification example: Sticker surface</h3>

    <div class="iteration-belt__intro">
      <p>
        A second rectification instance isolates a dense, high-frequency surface (stickers + paint), where interpolation
        differences appear as small but spatially widespread changes. The inverse mapping is held fixed; only the
        interpolation operator varies.
      </p>
    </div>

    <div class="viz-pair" style="--viz-pair-max: 36rem;" role="group"
      aria-label="Rectification correspondences for the sticker example">
      <figure class="viz-pair__panel">
        <div class="viz-pair__title">Source (selected corners)</div>
        <img class="viz-pair__image" src="media/3_warp/pink/points_imgA.png"
          alt="Sticker photo with selected corner points on the planar region" loading="lazy">
      </figure>

      <figure class="viz-pair__panel">
        <div class="viz-pair__title">Target (ideal rectangle)</div>
        <img class="viz-pair__image" src="media/3_warp/pink/points_imgB.png"
          alt="Target rectangle with corresponding corner points" loading="lazy">
      </figure>
    </div>

    <div class="viz-pair" style="--viz-pair-max: 36rem;" role="group"
      aria-label="Rectified output comparison for the sticker example">
      <figure class="viz-pair__panel">
        <div class="viz-pair__title">Nearest neighbor</div>
        <img class="viz-pair__image" src="media/3_warp/pink/nn/pink_warped.png"
          alt="Sticker rectification using nearest-neighbor interpolation" loading="lazy">
      </figure>

      <figure class="viz-pair__panel">
        <div class="viz-pair__title">Bilinear</div>
        <img class="viz-pair__image" src="media/3_warp/pink/bilinear/pink_warped.png"
          alt="Sticker rectification using bilinear interpolation" loading="lazy">
      </figure>
    </div>
    <!-- 
  <div class="viz-pair" style="--viz-pair-max: 36rem;" role="group"
       aria-label="Alpha mask comparison for the sticker example">
    <figure class="viz-pair__panel">
      <div class="viz-pair__title">NN mask</div>
      <img class="viz-pair__image" src="media/3_warp/pink/nn/pink_warped_mask.png"
           alt="Alpha mask for nearest-neighbor sticker rectification" loading="lazy">
    </figure>

    <figure class="viz-pair__panel">
      <div class="viz-pair__title">Bilinear mask</div>
      <img class="viz-pair__image" src="media/3_warp/pink/bilinear/pink_warped_mask.png"
           alt="Alpha mask for bilinear sticker rectification" loading="lazy">
    </figure>
  </div> -->

    <div class="iteration-belt__outro">
      <p>
        End-to-end time is the composition of two distinct costs: the warping kernel itself (the inner loop that
        evaluates
        <em>H</em><sup>−1</sup>, performs bounds checks, and interpolates), and the surrounding pipeline overhead
        (output
        buffer allocation, alpha-mask bookkeeping, image encoding, and filesystem writes). The measurements in this
        section
        show that <code>time_warp_s</code> is on the order of 0.05–0.19s, while <code>time_total_s</code> is ~5–6s; the
        latter
        therefore dominates the wall-clock outcome, and small variations in overhead can exceed the interpolation gap.
      </p>
    </div>


    <figure class="viz-pair__panel" style="max-width: 60rem; margin: 1.25rem auto 0;">
      <div class="viz-pair__title">Difference map (|bilinear − NN| × 10)</div>
      <img class="viz-pair__image" src="media/3_warp/pink/diff_x10.png"
        alt="Amplified absolute difference between bilinear and nearest-neighbor sticker warps (scaled by 10)"
        loading="lazy">
    </figure>

    <div class="code-snippets" aria-label="Numeric difference between bilinear and nearest neighbor outputs (sticker)">
      <div class="code-snippets__title">Numeric difference (sticker)</div>
      <details class="code-snippet" open>
        <summary>diff statistics</summary>
        <div class="code-snippet__body">
          <pre class="code-block"><code>max abs diff: 122
mean abs diff: 2.350457083333333
pct nonzero:   0.78648625</code></pre>
        </div>
      </details>
    </div>

    <div class="iteration-belt__outro">

      <p>
        This separation explains why “faster interpolation” is not guaranteed to produce a faster run. Nearest neighbor
        is
        cheaper per pixel, yet the implementation can still spend most of its time outside the interpolator: PNG writing
        and
        repeated visualization dumps introduce large fixed costs; repeated allocations and dtype conversions introduce
        memory
        bandwidth costs; and branch-heavy bounds checks can reduce the advantage of a simpler stencil. When the kernel
        is a
        small fraction of total time, cache state, OS scheduling, and disk throughput variability can invert the
        ordering
        between methods across runs without contradicting the per-pixel arithmetic expectation.
      </p>
    </div>


    <div class="code-snippets" aria-label="Sticker rectification runtime comparison">
      <div class="code-snippets__title">Runtime comparison (sticker)</div>

      <details class="code-snippet" open>
        <summary>pink → form (inverse warping)</summary>
        <div class="code-snippet__body">
          <pre class="code-block"><code>Nearest neighbor:
                time_warp_s  = 0.053140
                time_total_s = 5.575044

              Bilinear:
                time_warp_s  = 0.172137
                time_total_s = 5.730197

              Δ warp  = +0.118997 s  (+223.93%)
              Δ total = +0.155153 s  (+2.78%)
            </code></pre>
        </div>
      </details>
    </div>

    <div class="iteration-belt__outro">
      
      <p>
        Optimization therefore decomposes cleanly into two targets. Kernel speed improves by reducing Python overhead
        and
        memory traffic: precompute <em>H</em><sup>−1</sup> once; compute the output bounding box once; reuse
        preallocated
        output/alpha buffers across runs; avoid per-pixel Python branching by vectorizing bounds checks where possible;
        and
        minimize temporaries and dtype casts. Pipeline speed improves by amortizing I/O: write fewer intermediate
        images,
        prefer lossless outputs only when needed for the deliverable, and batch or disable expensive debug
        visualizations when
        benchmarking. Reporting both <code>time_warp_s</code> and <code>time_total_s</code> makes these two regimes
        explicit:
        changes that accelerate the interpolator may only be visible in <code>time_warp_s</code> unless I/O and
        allocation
        overhead are also reduced.
      </p>
    </div>

  </section>


  <!-- =============================================================== A.4: Blend images into a mosaic  =============================================================== -->
  <section class="content gold-glass iteration-belt" id="a4">
    <h2 class="section-heading">A.4 Blend into a Mosaic</h2>

    <div class="iteration-belt__intro">
      <p>
        Deliverables: Show source images and results for three mosaics (include blending/masking details).
      </p>
    </div>
  </section>

  <script src="../../script.js" defer></script>
</body>

</html>